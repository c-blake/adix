nimTitle	lptabz	adix/lptabz.html	module adix/lptabz		0
nim	LPTabz	adix/lptabz.html#LPTabz	object LPTabz		55
nim	LPSetz	adix/lptabz.html#LPSetz	type LPSetz		66
nim	LPTab	adix/lptabz.html#LPTab	type LPTab		67
nim	LPSet	adix/lptabz.html#LPSet	type LPSet		68
nim	lpInitialSize	adix/lptabz.html#lpInitialSize	var lpInitialSize		70
nim	lpNumer	adix/lptabz.html#lpNumer	var lpNumer		71
nim	lpDenom	adix/lptabz.html#lpDenom	var lpDenom		72
nim	lpMinFree	adix/lptabz.html#lpMinFree	var lpMinFree		73
nim	lpGrowPow2	adix/lptabz.html#lpGrowPow2	var lpGrowPow2		74
nim	lpRobinHood	adix/lptabz.html#lpRobinHood	var lpRobinHood		75
nim	lpRehash	adix/lptabz.html#lpRehash	var lpRehash		76
nim	lpWarn	adix/lptabz.html#lpWarn	const lpWarn		86
nim	save	adix/lptabz.html#save,LPTabz[K,V,Z,z],string	proc save[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; pathStub: string)		92
nim	load	adix/lptabz.html#load,LPTabz[K,V,Z,z],string	proc load[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; path: string)		110
nim	loadLPTabz	adix/lptabz.html#loadLPTabz,string	proc loadLPTabz[K, V, Z; z: static int](path: string): LPTabz[K, V, Z, z]		136
nim	mmap	adix/lptabz.html#mmap,LPTabz[K,V,Z,z],string	proc mmap[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; path: string)		139
nim	len	adix/lptabz.html#len,LPTabz[K,V,Z,z]	proc len[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): int		168
nim	getCap	adix/lptabz.html#getCap,LPTabz[K,V,Z,z]	proc getCap[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): int		186
nim	depths	adix/lptabz.html#depths,LPTabz[K,V,Z,z]	proc depths[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): seq[int]		333
nim	init	adix/lptabz.html#init,LPTabz[K,V,Z,z]	proc init[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z];\n                             initialSize = lpInitialSize; numer = lpNumer;\n                             denom = lpDenom; minFree = lpMinFree;\n                             growPow2 = lpGrowPow2; rehash = lpRehash;\n                             robinhood = lpRobinHood)		445
nim	setCap	adix/lptabz.html#setCap,LPTabz[K,V,Z,z],int	proc setCap[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; newSize = -1)		468
nim	initLPTabz	adix/lptabz.html#initLPTabz	proc initLPTabz[K, V, Z; z: static int](initialSize = lpInitialSize; numer = lpNumer;\n                                   denom = lpDenom; minFree = lpMinFree;\n                                   growPow2 = lpGrowPow2; rehash = lpRehash;\n                                   robinhood = lpRobinHood): LPTabz[K, V, Z, z]		542
nim	setPolicy	adix/lptabz.html#setPolicy,LPTabz[K,V,Z,z]	proc setPolicy[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; numer = lpNumer;\n                                  denom = lpDenom; minFree = lpMinFree;\n                                  growPow2 = lpGrowPow2; rehash = lpRehash;\n                                  robinhood = lpRobinHood)		547
nim	rightSize	adix/lptabz.html#rightSize,int,int,int,int	proc rightSize(count: int; numer = 0; denom = 0; minFree = 0): int		558
nim	contains	adix/lptabz.html#contains,LPTabz[K,V,Z,z],K	proc contains[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): bool		561
nim	containsOrIncl	adix/lptabz.html#containsOrIncl,LPTabz[K,void,Z,z],K	proc containsOrIncl[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: K): bool		565
nim	setOrIncl	adix/lptabz.html#setOrIncl,LPTabz[K,void,Z,z],K	proc setOrIncl[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: K): bool		570
nim	mgetOrPut	adix/lptabz.html#mgetOrPut,LPTabz[K,V,Z,z],K,V	proc mgetOrPut[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V): var V		575
nim	mgetOrPut	adix/lptabz.html#mgetOrPut,LPTabz[K,V,Z,z],K,V,bool	proc mgetOrPut[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V;\n                                  had: var bool): var V		580
nim	editOrInit	adix/lptabz.html#editOrInit.t,LPTabz[K,V,Z,z],K,untyped,untyped,untyped	template editOrInit[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                   v, found, missing: untyped): untyped		588
nim	withIt	adix/lptabz.html#withIt.t,LPTabz[K,V,Z,z],K,,	template withIt[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; k: K; edit, init): untyped		600
nim	getItOrFail	adix/lptabz.html#getItOrFail.t,LPTabz[K,V,Z,z],K,,	template getItOrFail[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; k: K; found, missing): untyped		612
nim	add	adix/lptabz.html#add,LPTabz[K,void,Z,z],K	proc add[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: K)		645
nim	add	adix/lptabz.html#add,LPTabz[K,V,Z,z],K,V	proc add[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V)		648
nim	missingOrExcl	adix/lptabz.html#missingOrExcl,LPTabz[K,V,Z,z],K	proc missingOrExcl[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K): bool		652
nim	take	adix/lptabz.html#take,LPTabz[K,void,Z,z],K	proc take[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: var K): bool		656
nim	take	adix/lptabz.html#take,LPTabz[K: not void,V: not void,Z,z],K,V	proc take[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                       val: var V): bool		660
nim	pop	adix/lptabz.html#pop,LPTabz[K,void,Z,z]	proc pop[K, Z; z: static int](t: var LPTabz[K, void, Z, z]): K		668
nim	pop	adix/lptabz.html#pop,LPTabz[K: not void,V: not void,Z,z]	proc pop[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]): (K, V)		680
nim	editKey	adix/lptabz.html#editKey,LPTabz[K,V,Z,z],K,K	proc editKey[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; old, new: K)		695
nim	nthKey	adix/lptabz.html#nthKey,LPTabz[K,void,Z,z],int	proc nthKey[K, Z; z: static int](t: LPTabz[K, void, Z, z]; n: int): K		713
nim	nthPair	adix/lptabz.html#nthPair,LPTabz[K: not void,V: not void,Z,z],int	proc nthPair[K, V: not void; Z; z: static int](t: LPTabz[K, V, Z, z]; n: int): (K, V)		720
nim	nthPair	adix/lptabz.html#nthPair,LPTabz[K: not void,V: not void,Z,z],int_2	proc nthPair[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]; n: int): (\n    K, ptr V)		727
nim	clear	adix/lptabz.html#clear,LPTabz[K,V,Z,z]	proc clear[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z])		735
nim	items	adix/lptabz.html#items.i,LPTabz[K,void,Z,z]	iterator items[K, Z; z: static int](s: LPTabz[K, void, Z, z]): K		768
nim	mitems	adix/lptabz.html#mitems.i,LPTabz[K,void,Z,z]	iterator mitems[K, Z; z: static int](s: var LPTabz[K, void, Z, z]): var K		771
nim	hcodes	adix/lptabz.html#hcodes.i,LPTabz[K,void,Z,z]	iterator hcodes[K, Z; z: static int](s: LPTabz[K, void, Z, z]): (int, Hash)		774
nim	allItems	adix/lptabz.html#allItems.i,LPTabz[K,void,Z,z],K	iterator allItems[K, Z; z: static int](s: LPTabz[K, void, Z, z]; key: K): K		781
nim	numItems	adix/lptabz.html#numItems,LPTabz[K,void,Z,z],K	proc numItems[K, Z; z: static int](t: LPTabz[K, void, Z, z]; key: K): int		792
nim	numItems	adix/lptabz.html#numItems.i,LPTabz[K,void,Z,z]	iterator numItems[K, Z; z: static int](t: LPTabz[K, void, Z, z]): (K, int)		795
nim	pairs	adix/lptabz.html#pairs.i,LPTabz[K,void,Z,z]	iterator pairs[K, Z; z: static int](t: LPTabz[K, void, Z, z]): (int, K)		798
nim	pairs	adix/lptabz.html#pairs.i,LPTabz[K,V,Z,z]	iterator pairs[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): (K, V)		802
nim	mpairs	adix/lptabz.html#mpairs.i,LPTabz[K,V,Z,z]	iterator mpairs[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]): (K, var V)		805
nim	keys	adix/lptabz.html#keys.i,LPTabz[K,V,Z,z]	iterator keys[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): K		808
nim	values	adix/lptabz.html#values.i,LPTabz[K,V,Z,z]	iterator values[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): V		811
nim	mvalues	adix/lptabz.html#mvalues.i,LPTabz[K,V,Z,z]	iterator mvalues[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]): var V		814
nim	allValues	adix/lptabz.html#allValues.i,LPTabz[K,V,Z,z],K	iterator allValues[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): V		817
nim	allValues	adix/lptabz.html#allValues.i,LPTabz[K,V,Z,z],seq[V]	iterator allValues[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; vals: var seq[V]): K		825
nim	allValues	adix/lptabz.html#allValues,LPTabz[K,V,Z,z],K,seq[V]	proc allValues[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K;\n                                  vals: var seq[V]): bool		831
nim	debugDump	adix/lptabz.html#debugDump,LPTabz[K,V,Z,z],string	proc debugDump[K, V, Z; z: static int](s: LPTabz[K, V, Z, z]; label = "")		837
nim	pop	adix/lptabz.html#pop,LPTabz[K,void,Z,z],K	proc pop[K, Z; z: static int](s: var LPTabz[K, void, Z, z]; key: var K): bool		849
nim	incl	adix/lptabz.html#incl,LPTabz[K,void,Z,z],K	proc incl[K, Z; z: static int](s: var LPTabz[K, void, Z, z]; elt: K)		852
nim	excl	adix/lptabz.html#excl,LPTabz[K,void,Z,z],K	proc excl[K, Z; z: static int](s: var LPTabz[K, void, Z, z]; elt: K)		855
nim	incl	adix/lptabz.html#incl,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc incl[K, Z; z: static int](s: var LPTabz[K, void, Z, z];\n                          other: LPTabz[K, void, Z, z])		858
nim	excl	adix/lptabz.html#excl,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc excl[K, Z; z: static int](s: var LPTabz[K, void, Z, z];\n                          other: LPTabz[K, void, Z, z])		862
nim	card	adix/lptabz.html#card,LPTabz[K,void,Z,z]	proc card[K, Z; z: static int](s: LPTabz[K, void, Z, z]): int		866
nim	union	adix/lptabz.html#union,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc union[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		868
nim	intersection	adix/lptabz.html#intersection,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc intersection[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K,\n    void, Z, z]		872
nim	difference	adix/lptabz.html#difference,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc difference[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void,\n    Z, z]		878
nim	symmetricDifference	adix/lptabz.html#symmetricDifference,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc symmetricDifference[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[\n    K, void, Z, z]		884
nim	`+`	adix/lptabz.html#+,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `+`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		890
nim	`*`	adix/lptabz.html#*,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `*`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		892
nim	`-`	adix/lptabz.html#-,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `-`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		894
nim	`-+-`	adix/lptabz.html#-+-,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `-+-`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		896
nim	disjoint	adix/lptabz.html#disjoint,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc disjoint[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): bool		899
nim	`<=`	adix/lptabz.html#<=,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `<=`[K, Z; z: static int](s, t: LPTabz[K, void, Z, z]): bool		904
nim	`<`	adix/lptabz.html#<,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `<`[K, Z; z: static int](s, t: LPTabz[K, void, Z, z]): bool		916
nim	`==`	adix/lptabz.html#==,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `==`[K, Z; z: static int](s, t: LPTabz[K, void, Z, z]): bool		919
nim	map	adix/lptabz.html#map,LPTabz[K,void,Z,z],proc(K)	proc map[K, A, Z; z: static int](data: LPTabz[K, void, Z, z];\n                            op: proc (x: K): A {.closure.}): LPTabz[A, void, Z,\n    z]		932
nim	toLPTabz	adix/lptabz.html#toLPTabz,openArray[K]	proc toLPTabz[K; V: void; Z; z: static int](keys: openArray[K]; dups = false): LPTabz[\n    K, V, Z, z]		937
nim	`$`	adix/lptabz.html#$,LPTabz[K,void,Z,z]	proc `$`[K, Z; z: static int](s: LPTabz[K, void, Z, z]): string		945
nim	hash	adix/lptabz.html#hash,LPTabz[K,void,Z,z]	proc hash[K, Z; z: static int](s: LPTabz[K, void, Z, z]): Hash		953
nim	depthStats	adix/lptabz.html#depthStats,LPTabz[K,V,Z,z]	proc depthStats[K, V, Z; z: static int](s: LPTabz[K, V, Z, z]): tuple[m1, m2: float,\n    mx: int]		957
nim	toLPTabz	adix/lptabz.html#toLPTabz,openArray[]	proc toLPTabz[K; V: not void; Z; z: static int](pairs: openArray[(K, V)];\n    dups = false): LPTabz[K, V, Z, z]		973
nim	`$`	adix/lptabz.html#$,LPTabz[K: not void,V: not void,Z,z]	proc `$`[K, V: not void; Z; z: static int](t: LPTabz[K, V, Z, z]): string		981
nim	pop	adix/lptabz.html#pop,LPTabz[K: not void,V: not void,Z,z],K,V	proc pop[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                      val: var V): bool		991
nim	withValue	adix/lptabz.html#withValue.t,LPTabz[K,V,Z,z],K,untyped,untyped	template withValue[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                  value, found: untyped): untyped		995
nim	withValue	adix/lptabz.html#withValue.t,LPTabz[K,V,Z,z],K,untyped,untyped,untyped	template withValue[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                  value, found, missing: untyped): untyped		1003
nim	`[]`	adix/lptabz.html#[],LPTabz[K,V,Z,z],K	proc `[]`[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): V		1012
nim	`[]`	adix/lptabz.html#[],LPTabz[K,V,Z,z],K_2	proc `[]`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K): var V		1018
nim	`[]=`	adix/lptabz.html#[]=,LPTabz[K,V,Z,z],K,V	proc `[]=`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V)		1025
nim	`{}`	adix/lptabz.html#{},LPTabz[K,V,Z,z],K	proc `{}`[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): V		1030
nim	`{}`	adix/lptabz.html#{},LPTabz[K,V,Z,z],K_2	proc `{}`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K): var V		1032
nim	`{}=`	adix/lptabz.html#{}=,LPTabz[K,V,Z,z],K,V	proc `{}=`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V)		1034
nim	hasKey	adix/lptabz.html#hasKey,LPTabz[K,V,Z,z],K	proc hasKey[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): bool		1037
nim	hasKeyOrPut	adix/lptabz.html#hasKeyOrPut,LPTabz[K,V,Z,z],K,V	proc hasKeyOrPut[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V): bool		1040
nim	getOrDefault	adix/lptabz.html#getOrDefault,LPTabz[K,V,Z,z],K,typeof(default(V))	proc getOrDefault[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K;\n                                     def = default(V)): V		1044
nim	del	adix/lptabz.html#del,LPTabz[K,V,Z,z],K	proc del[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K)		1050
nim	`==`	adix/lptabz.html#==,LPTabz[K: not void,V: not void,Z,z],LPTabz[K: not void,V: not void,Z,z]	proc `==`[K, V: not void; Z; z: static int](x, y: LPTabz[K, V, Z, z]): bool		1055
nim	indexBy	adix/lptabz.html#indexBy,A,proc(V)	proc indexBy[A, K, V, Z; z: static int](collection: A; index: proc (x: V): K): LPTabz[\n    K, V, Z, z]		1070
nim	inc	adix/lptabz.html#inc,LPTabz[K,V,Z,z],K,V	proc inc[K, V, Z; z: static int](c: var LPTabz[K, V, Z, z]; key: K; amount: V = 1)		1076
nim	merge	adix/lptabz.html#merge,LPTabz[K,V,Z,z],LPTabz[K,V,Z,z]	proc merge[K, V, Z; z: static int](c: var LPTabz[K, V, Z, z]; b: LPTabz[K, V, Z, z])		1085
nim	topByVal	adix/lptabz.html#topByVal.i,LPTabz[K,V,Z,z],int	iterator topByVal[K, V, Z; z: static int](c: LPTabz[K, V, Z, z]; n = 10; min = V.low;\n                                 order = Cheap): (K, V)		1089
nim	mostCommon	adix/lptabz.html#mostCommon.i,openArray[K],int	iterator mostCommon[K](xs: openArray[K]; n = 10): (K, int)		1097
nim	initLPSetz	adix/lptabz.html#initLPSetz	proc initLPSetz[K, Z; z: static int](initialSize = lpInitialSize; numer = lpNumer;\n                                denom = lpDenom; minFree = lpMinFree;\n                                growPow2 = lpGrowPow2; rehash = lpRehash;\n                                robinhood = lpRobinHood): LPSetz[K, Z, z]		1104
nim	initLPSet	adix/lptabz.html#initLPSet	proc initLPSet[K](initialSize = lpInitialSize; numer = lpNumer; denom = lpDenom;\n             minFree = lpMinFree; growPow2 = lpGrowPow2; rehash = lpRehash;\n             robinhood = lpRobinHood): LPSet[K]		1111
nim	initLPTab	adix/lptabz.html#initLPTab	proc initLPTab[K, V](initialSize = lpInitialSize; numer = lpNumer; denom = lpDenom;\n                minFree = lpMinFree; growPow2 = lpGrowPow2; rehash = lpRehash;\n                robinhood = lpRobinHood): LPTab[K, V]		1118
nimgrp	pop	adix/lptabz.html#pop-procs-all	proc		668
nimgrp	$	adix/lptabz.html#$-procs-all	proc		945
nimgrp	add	adix/lptabz.html#add-procs-all	proc		645
nimgrp	incl	adix/lptabz.html#incl-procs-all	proc		852
nimgrp	nthpair	adix/lptabz.html#nthPair-procs-all	proc		720
nimgrp	take	adix/lptabz.html#take-procs-all	proc		656
nimgrp	mgetorput	adix/lptabz.html#mgetOrPut-procs-all	proc		575
nimgrp	{}	adix/lptabz.html#{}-procs-all	proc		1030
nimgrp	excl	adix/lptabz.html#excl-procs-all	proc		855
nimgrp	tolptabz	adix/lptabz.html#toLPTabz-procs-all	proc		937
nimgrp	==	adix/lptabz.html#==-procs-all	proc		919
nimgrp	[]	adix/lptabz.html#[]-procs-all	proc		1012
nimgrp	pairs	adix/lptabz.html#pairs-iterators-all	iterator		798
nimgrp	allvalues	adix/lptabz.html#allValues-iterators-all	iterator		817
nimgrp	withvalue	adix/lptabz.html#withValue-templates-all	template		995
