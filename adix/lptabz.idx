nimTitle	lptabz	adix/lptabz.html	module adix/lptabz		0
nim	LPTabz	adix/lptabz.html#LPTabz	object LPTabz		54
nim	LPSetz	adix/lptabz.html#LPSetz	type LPSetz		65
nim	LPTab	adix/lptabz.html#LPTab	type LPTab		66
nim	LPSet	adix/lptabz.html#LPSet	type LPSet		67
nim	lpInitialSize	adix/lptabz.html#lpInitialSize	var lpInitialSize		69
nim	lpNumer	adix/lptabz.html#lpNumer	var lpNumer		70
nim	lpDenom	adix/lptabz.html#lpDenom	var lpDenom		71
nim	lpMinFree	adix/lptabz.html#lpMinFree	var lpMinFree		72
nim	lpGrowPow2	adix/lptabz.html#lpGrowPow2	var lpGrowPow2		73
nim	lpRobinHood	adix/lptabz.html#lpRobinHood	var lpRobinHood		74
nim	lpRehash	adix/lptabz.html#lpRehash	var lpRehash		75
nim	lpWarn	adix/lptabz.html#lpWarn	var lpWarn		86
nim	lpMaxWarn	adix/lptabz.html#lpMaxWarn	var lpMaxWarn		87
nim	save	adix/lptabz.html#save,LPTabz[K,V,Z,z],string	proc save[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; pathStub: string)		90
nim	load	adix/lptabz.html#load,LPTabz[K,V,Z,z],string	proc load[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; path: string)		108
nim	loadLPTabz	adix/lptabz.html#loadLPTabz,string	proc loadLPTabz[K, V, Z; z: static int](path: string): LPTabz[K, V, Z, z]		134
nim	mmap	adix/lptabz.html#mmap,LPTabz[K,V,Z,z],string	proc mmap[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; path: string)		137
nim	len	adix/lptabz.html#len,LPTabz[K,V,Z,z]	proc len[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): int		166
nim	getCap	adix/lptabz.html#getCap,LPTabz[K,V,Z,z]	proc getCap[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): int		184
nim	depths	adix/lptabz.html#depths,LPTabz[K,V,Z,z]	proc depths[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): seq[int]		331
nim	init	adix/lptabz.html#init,LPTabz[K,V,Z,z]	proc init[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z];\n                             initialSize = lpInitialSize; numer = lpNumer;\n                             denom = lpDenom; minFree = lpMinFree;\n                             growPow2 = lpGrowPow2; rehash = lpRehash;\n                             robinhood = lpRobinHood)		442
nim	setCap	adix/lptabz.html#setCap,LPTabz[K,V,Z,z],int	proc setCap[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; newSize = -1)		465
nim	initLPTabz	adix/lptabz.html#initLPTabz	proc initLPTabz[K, V, Z; z: static int](initialSize = lpInitialSize; numer = lpNumer;\n                                   denom = lpDenom; minFree = lpMinFree;\n                                   growPow2 = lpGrowPow2; rehash = lpRehash;\n                                   robinhood = lpRobinHood): LPTabz[K, V, Z, z]		539
nim	setPolicy	adix/lptabz.html#setPolicy,LPTabz[K,V,Z,z]	proc setPolicy[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; numer = lpNumer;\n                                  denom = lpDenom; minFree = lpMinFree;\n                                  growPow2 = lpGrowPow2; rehash = lpRehash;\n                                  robinhood = lpRobinHood)		544
nim	rightSize	adix/lptabz.html#rightSize,int,int,int,int	proc rightSize(count: int; numer = 0; denom = 0; minFree = 0): int		555
nim	contains	adix/lptabz.html#contains,LPTabz[K,V,Z,z],K	proc contains[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): bool		558
nim	containsOrIncl	adix/lptabz.html#containsOrIncl,LPTabz[K,void,Z,z],K	proc containsOrIncl[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: K): bool		562
nim	setOrIncl	adix/lptabz.html#setOrIncl,LPTabz[K,void,Z,z],K	proc setOrIncl[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: K): bool		567
nim	mgetOrPut	adix/lptabz.html#mgetOrPut,LPTabz[K,V,Z,z],K,V	proc mgetOrPut[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V): var V		572
nim	mgetOrPut	adix/lptabz.html#mgetOrPut,LPTabz[K,V,Z,z],K,V,bool	proc mgetOrPut[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V;\n                                  had: var bool): var V		577
nim	editOrInit	adix/lptabz.html#editOrInit.t,LPTabz[K,V,Z,z],K,untyped,untyped,untyped	template editOrInit[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                   v, found, missing: untyped): untyped		585
nim	withIt	adix/lptabz.html#withIt.t,LPTabz[K,V,Z,z],K,,	template withIt[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; k: K; edit, init): untyped		597
nim	getItOrFail	adix/lptabz.html#getItOrFail.t,LPTabz[K,V,Z,z],K,,	template getItOrFail[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; k: K; found, missing): untyped		609
nim	add	adix/lptabz.html#add,LPTabz[K,void,Z,z],K	proc add[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: K)		642
nim	add	adix/lptabz.html#add,LPTabz[K,V,Z,z],K,V	proc add[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V)		645
nim	missingOrExcl	adix/lptabz.html#missingOrExcl,LPTabz[K,V,Z,z],K	proc missingOrExcl[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K): bool		649
nim	take	adix/lptabz.html#take,LPTabz[K,void,Z,z],K	proc take[K, Z; z: static int](t: var LPTabz[K, void, Z, z]; key: var K): bool		653
nim	take	adix/lptabz.html#take,LPTabz[K: not void,V: not void,Z,z],K,V	proc take[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                       val: var V): bool		657
nim	pop	adix/lptabz.html#pop,LPTabz[K,void,Z,z]	proc pop[K, Z; z: static int](t: var LPTabz[K, void, Z, z]): K		665
nim	pop	adix/lptabz.html#pop,LPTabz[K: not void,V: not void,Z,z]	proc pop[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]): (K, V)		677
nim	editKey	adix/lptabz.html#editKey,LPTabz[K,V,Z,z],K,K	proc editKey[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; old, new: K)		692
nim	nthKey	adix/lptabz.html#nthKey,LPTabz[K,void,Z,z],int	proc nthKey[K, Z; z: static int](t: LPTabz[K, void, Z, z]; n: int): K		710
nim	nthPair	adix/lptabz.html#nthPair,LPTabz[K: not void,V: not void,Z,z],int	proc nthPair[K, V: not void; Z; z: static int](t: LPTabz[K, V, Z, z]; n: int): (K, V)		717
nim	nthPair	adix/lptabz.html#nthPair,LPTabz[K: not void,V: not void,Z,z],int_2	proc nthPair[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]; n: int): (\n    K, ptr V)		724
nim	clear	adix/lptabz.html#clear,LPTabz[K,V,Z,z]	proc clear[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z])		732
nim	items	adix/lptabz.html#items.i,LPTabz[K,void,Z,z]	iterator items[K, Z; z: static int](s: LPTabz[K, void, Z, z]): K		765
nim	mitems	adix/lptabz.html#mitems.i,LPTabz[K,void,Z,z]	iterator mitems[K, Z; z: static int](s: var LPTabz[K, void, Z, z]): var K		768
nim	hcodes	adix/lptabz.html#hcodes.i,LPTabz[K,void,Z,z]	iterator hcodes[K, Z; z: static int](s: LPTabz[K, void, Z, z]): (int, Hash)		771
nim	allItems	adix/lptabz.html#allItems.i,LPTabz[K,void,Z,z],K	iterator allItems[K, Z; z: static int](s: LPTabz[K, void, Z, z]; key: K): K		778
nim	numItems	adix/lptabz.html#numItems,LPTabz[K,void,Z,z],K	proc numItems[K, Z; z: static int](t: LPTabz[K, void, Z, z]; key: K): int		789
nim	numItems	adix/lptabz.html#numItems.i,LPTabz[K,void,Z,z]	iterator numItems[K, Z; z: static int](t: LPTabz[K, void, Z, z]): (K, int)		792
nim	pairs	adix/lptabz.html#pairs.i,LPTabz[K,void,Z,z]	iterator pairs[K, Z; z: static int](t: LPTabz[K, void, Z, z]): (int, K)		795
nim	pairs	adix/lptabz.html#pairs.i,LPTabz[K,V,Z,z]	iterator pairs[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): (K, V)		799
nim	mpairs	adix/lptabz.html#mpairs.i,LPTabz[K,V,Z,z]	iterator mpairs[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]): (K, var V)		802
nim	keys	adix/lptabz.html#keys.i,LPTabz[K,V,Z,z]	iterator keys[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): K		805
nim	values	adix/lptabz.html#values.i,LPTabz[K,V,Z,z]	iterator values[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]): V		808
nim	mvalues	adix/lptabz.html#mvalues.i,LPTabz[K,V,Z,z]	iterator mvalues[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]): var V		811
nim	allValues	adix/lptabz.html#allValues.i,LPTabz[K,V,Z,z],K	iterator allValues[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): V		814
nim	allValues	adix/lptabz.html#allValues.i,LPTabz[K,V,Z,z],seq[V]	iterator allValues[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; vals: var seq[V]): K		822
nim	allValues	adix/lptabz.html#allValues,LPTabz[K,V,Z,z],K,seq[V]	proc allValues[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K;\n                                  vals: var seq[V]): bool		828
nim	debugDump	adix/lptabz.html#debugDump,LPTabz[K,V,Z,z],string	proc debugDump[K, V, Z; z: static int](s: LPTabz[K, V, Z, z]; label = "")		834
nim	pop	adix/lptabz.html#pop,LPTabz[K,void,Z,z],K	proc pop[K, Z; z: static int](s: var LPTabz[K, void, Z, z]; key: var K): bool		846
nim	incl	adix/lptabz.html#incl,LPTabz[K,void,Z,z],K	proc incl[K, Z; z: static int](s: var LPTabz[K, void, Z, z]; elt: K)		849
nim	excl	adix/lptabz.html#excl,LPTabz[K,void,Z,z],K	proc excl[K, Z; z: static int](s: var LPTabz[K, void, Z, z]; elt: K)		852
nim	incl	adix/lptabz.html#incl,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc incl[K, Z; z: static int](s: var LPTabz[K, void, Z, z];\n                          other: LPTabz[K, void, Z, z])		855
nim	excl	adix/lptabz.html#excl,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc excl[K, Z; z: static int](s: var LPTabz[K, void, Z, z];\n                          other: LPTabz[K, void, Z, z])		859
nim	card	adix/lptabz.html#card,LPTabz[K,void,Z,z]	proc card[K, Z; z: static int](s: LPTabz[K, void, Z, z]): int		863
nim	union	adix/lptabz.html#union,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc union[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		865
nim	intersection	adix/lptabz.html#intersection,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc intersection[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K,\n    void, Z, z]		869
nim	difference	adix/lptabz.html#difference,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc difference[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void,\n    Z, z]		875
nim	symmetricDifference	adix/lptabz.html#symmetricDifference,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc symmetricDifference[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[\n    K, void, Z, z]		881
nim	`+`	adix/lptabz.html#+,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `+`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		887
nim	`*`	adix/lptabz.html#*,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `*`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		889
nim	`-`	adix/lptabz.html#-,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `-`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		891
nim	`-+-`	adix/lptabz.html#-+-,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `-+-`[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): LPTabz[K, void, Z, z]		893
nim	disjoint	adix/lptabz.html#disjoint,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc disjoint[K, Z; z: static int](s1, s2: LPTabz[K, void, Z, z]): bool		896
nim	`<=`	adix/lptabz.html#<=,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `<=`[K, Z; z: static int](s, t: LPTabz[K, void, Z, z]): bool		901
nim	`<`	adix/lptabz.html#<,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `<`[K, Z; z: static int](s, t: LPTabz[K, void, Z, z]): bool		913
nim	`==`	adix/lptabz.html#==,LPTabz[K,void,Z,z],LPTabz[K,void,Z,z]	proc `==`[K, Z; z: static int](s, t: LPTabz[K, void, Z, z]): bool		916
nim	map	adix/lptabz.html#map,LPTabz[K,void,Z,z],proc(K)	proc map[K, A, Z; z: static int](data: LPTabz[K, void, Z, z];\n                            op: proc (x: K): A {.closure.}): LPTabz[A, void, Z,\n    z]		929
nim	toLPTabz	adix/lptabz.html#toLPTabz,openArray[K]	proc toLPTabz[K; V: void; Z; z: static int](keys: openArray[K]; dups = false): LPTabz[\n    K, V, Z, z]		934
nim	`$`	adix/lptabz.html#$,LPTabz[K,void,Z,z]	proc `$`[K, Z; z: static int](s: LPTabz[K, void, Z, z]): string		942
nim	hash	adix/lptabz.html#hash,LPTabz[K,void,Z,z]	proc hash[K, Z; z: static int](s: LPTabz[K, void, Z, z]): Hash		950
nim	depthStats	adix/lptabz.html#depthStats,LPTabz[K,V,Z,z]	proc depthStats[K, V, Z; z: static int](s: LPTabz[K, V, Z, z]): tuple[m1, m2: float,\n    mx: int]		954
nim	toLPTabz	adix/lptabz.html#toLPTabz,openArray[]	proc toLPTabz[K; V: not void; Z; z: static int](pairs: openArray[(K, V)];\n    dups = false): LPTabz[K, V, Z, z]		970
nim	`$`	adix/lptabz.html#$,LPTabz[K: not void,V: not void,Z,z]	proc `$`[K, V: not void; Z; z: static int](t: LPTabz[K, V, Z, z]): string		978
nim	pop	adix/lptabz.html#pop,LPTabz[K: not void,V: not void,Z,z],K,V	proc pop[K, V: not void; Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                      val: var V): bool		988
nim	withValue	adix/lptabz.html#withValue.t,LPTabz[K,V,Z,z],K,untyped,untyped	template withValue[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                  value, found: untyped): untyped		992
nim	withValue	adix/lptabz.html#withValue.t,LPTabz[K,V,Z,z],K,untyped,untyped,untyped	template withValue[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K;\n                                  value, found, missing: untyped): untyped		1000
nim	`[]`	adix/lptabz.html#[],LPTabz[K,V,Z,z],K	proc `[]`[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): V		1009
nim	`[]`	adix/lptabz.html#[],LPTabz[K,V,Z,z],K_2	proc `[]`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K): var V		1015
nim	`[]=`	adix/lptabz.html#[]=,LPTabz[K,V,Z,z],K,V	proc `[]=`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V)		1022
nim	`{}`	adix/lptabz.html#{},LPTabz[K,V,Z,z],K	proc `{}`[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): V		1027
nim	`{}`	adix/lptabz.html#{},LPTabz[K,V,Z,z],K_2	proc `{}`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K): var V		1029
nim	`{}=`	adix/lptabz.html#{}=,LPTabz[K,V,Z,z],K,V	proc `{}=`[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V)		1031
nim	hasKey	adix/lptabz.html#hasKey,LPTabz[K,V,Z,z],K	proc hasKey[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K): bool		1034
nim	hasKeyOrPut	adix/lptabz.html#hasKeyOrPut,LPTabz[K,V,Z,z],K,V	proc hasKeyOrPut[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K; val: V): bool		1037
nim	getOrDefault	adix/lptabz.html#getOrDefault,LPTabz[K,V,Z,z],K,typeof(default(V))	proc getOrDefault[K, V, Z; z: static int](t: LPTabz[K, V, Z, z]; key: K;\n                                     def = default(V)): V		1041
nim	del	adix/lptabz.html#del,LPTabz[K,V,Z,z],K	proc del[K, V, Z; z: static int](t: var LPTabz[K, V, Z, z]; key: K)		1047
nim	`==`	adix/lptabz.html#==,LPTabz[K: not void,V: not void,Z,z],LPTabz[K: not void,V: not void,Z,z]	proc `==`[K, V: not void; Z; z: static int](x, y: LPTabz[K, V, Z, z]): bool		1052
nim	indexBy	adix/lptabz.html#indexBy,A,proc(V)	proc indexBy[A, K, V, Z; z: static int](collection: A; index: proc (x: V): K): LPTabz[\n    K, V, Z, z]		1067
nim	inc	adix/lptabz.html#inc,LPTabz[K,V,Z,z],K,V	proc inc[K, V, Z; z: static int](c: var LPTabz[K, V, Z, z]; key: K; amount: V = 1)		1073
nim	merge	adix/lptabz.html#merge,LPTabz[K,V,Z,z],LPTabz[K,V,Z,z]	proc merge[K, V, Z; z: static int](c: var LPTabz[K, V, Z, z]; b: LPTabz[K, V, Z, z])		1082
nim	topByVal	adix/lptabz.html#topByVal.i,LPTabz[K,V,Z,z],int	iterator topByVal[K, V, Z; z: static int](c: LPTabz[K, V, Z, z]; n = 10; min = V.low;\n                                 order = Cheap): (K, V)		1086
nim	mostCommon	adix/lptabz.html#mostCommon.i,openArray[K],int	iterator mostCommon[K](xs: openArray[K]; n = 10): (K, int)		1094
nim	initLPSetz	adix/lptabz.html#initLPSetz	proc initLPSetz[K, Z; z: static int](initialSize = lpInitialSize; numer = lpNumer;\n                                denom = lpDenom; minFree = lpMinFree;\n                                growPow2 = lpGrowPow2; rehash = lpRehash;\n                                robinhood = lpRobinHood): LPSetz[K, Z, z]		1101
nim	initLPSet	adix/lptabz.html#initLPSet	proc initLPSet[K](initialSize = lpInitialSize; numer = lpNumer; denom = lpDenom;\n             minFree = lpMinFree; growPow2 = lpGrowPow2; rehash = lpRehash;\n             robinhood = lpRobinHood): LPSet[K]		1108
nim	initLPTab	adix/lptabz.html#initLPTab	proc initLPTab[K, V](initialSize = lpInitialSize; numer = lpNumer; denom = lpDenom;\n                minFree = lpMinFree; growPow2 = lpGrowPow2; rehash = lpRehash;\n                robinhood = lpRobinHood): LPTab[K, V]		1115
nimgrp	pop	adix/lptabz.html#pop-procs-all	proc		665
nimgrp	$	adix/lptabz.html#$-procs-all	proc		942
nimgrp	add	adix/lptabz.html#add-procs-all	proc		642
nimgrp	incl	adix/lptabz.html#incl-procs-all	proc		849
nimgrp	nthpair	adix/lptabz.html#nthPair-procs-all	proc		717
nimgrp	take	adix/lptabz.html#take-procs-all	proc		653
nimgrp	mgetorput	adix/lptabz.html#mgetOrPut-procs-all	proc		572
nimgrp	{}	adix/lptabz.html#{}-procs-all	proc		1027
nimgrp	excl	adix/lptabz.html#excl-procs-all	proc		852
nimgrp	tolptabz	adix/lptabz.html#toLPTabz-procs-all	proc		934
nimgrp	==	adix/lptabz.html#==-procs-all	proc		916
nimgrp	[]	adix/lptabz.html#[]-procs-all	proc		1009
nimgrp	pairs	adix/lptabz.html#pairs-iterators-all	iterator		795
nimgrp	allvalues	adix/lptabz.html#allValues-iterators-all	iterator		814
nimgrp	withvalue	adix/lptabz.html#withValue-templates-all	template		992
