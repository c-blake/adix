##[`xhist1.def` is a template to make a histogram type for univariate/1D data
monotonically transformed over (0, +Inf) for binning against any integer-keyed
backing histogram.

The backing histogram is itself generic over time weighting kernels (bist,
lmbist, embist..) and those over their counter types (exponential time-decay
needs `SomeFloat`).  The example program at the bottom of the module should
mostly show how to use this.

This generalizes `adix/lghisto`.  Quantile error is bounded by quantization
error which is <~1/2 transformed bin width - eg. ~10^(log10(b/a)/n) w/X=log.
Space-time trade-offs depend on how boundable data ranges are, but underflows &
overflows are at least counted (until counters saturate!).

The template definitions are not marked for export - use `export` to do that.
Also, I am aware that dynamic dispatch could be useful here, but that adds a
noticeable overhead in a tight loop over big data.

NOTE: *Outer* code manages running/moving data window logic with `std/deques` |
whatever - types generated by this only do bin mapping / histogram calls.]##

when not declared addFloat: import std/formatfloat; export formatfloat
from std/math import isNaN; from std/fenv import epsilon
export isNaN, epsilon
import cligen/sysUt; export sysUt

template def*(T, X, X⁻¹, H; Hini: typed = false; Harg=0.0) =
  ##[ Here `T` is the type that will be defined along with an `init T`, `H` is
  the type of histogram (e.g. `Bist[uint32]`), `X` is an expression transforming
  monotonically over `(0, +Inf)` some input `x`, e.g. `ln`, while `X⁻¹` is its
  inverse function expression, e.g. `exp`.  So, `def Histo,ln,exp,Bist[uint32]`
  is one instantiation.  Besides defining the type, this also defines routines
  documented in detail over in https://c-blake.github.io/adix/adix/lghisto.html
   * func underflows(s: T): type(s.hist.cdf 0)      # bin[0]
   * func overflows(s: T) : type(s.hist.cdf 0)      # bin[^1]
   * func low(s: T): float                          # `.a`
   * func high(s: T): float                         # `.b`
   * func nBin(s: T): int                           # `.n` - 2*n+1 is num.bins
   * func hist(s: T): H                             # `.hist` - backing histo
   * proc init(s: var T, a=1e-16, b=1e20, n=8300)   # init w/2*n+1 bins
   * proc initT(a=1e-16, b=1e20, n=8300): T         # Same, but w/TypeName
   * func space(s: T): int                          # Est.of total bytes used
   * func tot(s: T): auto                           # Total count weight
   * func toIx[F](s: T, x: F): int                  # x -> bin index
   * func fromIx[F](s: T, i: int, offset: F=0.5): F # bin index -> bin center
   * func binAB[F](s: T, x: F): (float, float)      # whole range for bin(`x`)
   * func add[F](s: var T, x: F, w: type(s.hist.cdf 0) = 1)  # inc wt by w
   * func pop[F](s: var T, x: F, w: type(s.hist.cdf 0) = 1)  # dec wt by w
   * iterator bins(s: T): (float, float, type(s.hist.cdf 0)) # yield (lo,hi,cnt)
   * proc `$`(s: T, nonZero=true): string                    # format histo
   * func quantile[F](s: T, q: F): F                # Basic quantile
   * func cdf[F](s: T, x: F): type(s.hist.cdf 0)    # Raw count; Callers /s.tot
   * func merge(dst: var T, src: T)                 # Cnts from src into dst ]##

  type `T` = object       ## histogram(X(x[])) with backing histogram `H`
    n*: int               ## number of bins
    a*, b*: float         ## histogram covers [-b, -a], (-a, a) in zero, [a, b]
    aX*, h*, hInv*: float ## pre-computes for index scale conversion
    hist*: H              ## actual smart array of counters: [0, 2*n] -> PMF/CDF
#Could also take option like `noNegative`, but untouched cache matters little.

  func underflows(s: `T`): type(s.hist.cdf 0) = s.hist.pmf 0
  func overflows(s: `T`) : type(s.hist.cdf 0) = s.hist.pmf 2*s.n
  func low(s: `T`): float      = s.a
  func high(s: `T`): float     = s.b
  func nBin(s: `T`): int       = s.n
  func hist(s: `T`): H         = s.hist

  proc init(s: var `T`, a=1e-16, b=1e20, n=8300) =
    ## Init histo w/2n+1 X-spaced bins: `[-∞..-b; -b..-a; 0; a..<b; b..∞]`.
    if b <= a: Value !! "inverted: [" & $a & "," & $b & "]"
    if a <= 0.0 or b <= 0.0: Value !! "a,b must both be >0"
    if n < 2: Value !! "n must >= 2"
    s.n    = n
    s.a    = a
    s.b    = b
    s.aX   = a.X
    s.h    = (b.X - s.aX)/float(n - 1)
    s.hInv = 1.0/s.h
    when Hini: s.hist.init 2*n + 1, Harg
    else     : s.hist.init 2*n + 1

  proc `init T`(a=1e-16, b=1e20, n=8300): `T` = result.init a, b, n
    ## Get Histo w/2n+1 X-spaced bins: `[-inf..<-b; -b..<-a; 0; a..<b; b..inf]`.

  func space(s: `T`): int = s.sizeof + s.hist.space
    ## Estimate space taken up by data structure in bytes

  func tot(s: `T`): auto = s.hist.tot ## Give total count weight

  func toIx[F](s: `T`, x: F): int =
    ##Find bin index for value `x`; Underflows get `[0]`, Overflows get `[2*n]`.
    if   x <= -s.a:
      if x >= -s.b: result = s.n - 1 - int( (X(-x) - s.aX)*s.hInv)
      else        : result = 0
    elif x >= +s.a:
      if x <= +s.b: result = s.n + 1 + int( (X(+x) - s.aX)*s.hInv)
      else        : result = 2*s.n
    else: result = s.n

  func fromIx[F](s: `T`, i: int, offset: F=0.5): F =
    ## X⁻¹-mean of left&right edge X-shifted `offset` fraction into bin
    if   i < s.n: -X⁻¹(s.aX + s.h*(F(s.n - i - 1) + F(1) - offset))
    elif i > s.n: +X⁻¹(s.aX + s.h*(F(i - s.n - 1) + offset))
    else: 0.0 # Bin containing x=zero cannot really be offset in the same way

  func binAB[F](s: `T`, x: F): (float, float) =
    ## Range in data space of the bin containing `x`; Costs 2 `fromIx`s.
    let i = s.toIx(x)
    if   i == 0      : result[0] = -Inf           ; result[1] = -s.b
    elif i == 1      : result[0] = -s.b           ; result[1] = s.fromIx(i,1.0)
    elif i == 2*s.n-1: result[0] = s.fromIx(i,0.0); result[1] = +s.b
    elif i == 2*s.n  : result[0] = +s.b           ; result[1] = +Inf
    elif x <  -s.a   : result[0] = s.fromIx(i,0.0); result[1] = s.fromIx(i,1.0)
    elif x >= +s.a   : result[0] = s.fromIx(i,0.0); result[1] = s.fromIx(i,1.0)
    else             : result[0] = -s.a           ; result[1] = +s.a

  func add[F](s: var `T`, x: F, w: type(s.hist.cdf 0) = 1) =
    ## Increment bin for value `x` by weight `w`
    if not isNaN(x): s.hist.inc s.toIx(x), w

  func pop[F](s: var `T`, x: F, w: type(s.hist.cdf 0) = 1) =
    ## Alias for `add` with a negative weight argument
    if not isNaN(x): s.hist.dec s.toIx(x), w

  iterator bins(s: `T`): (float, float, type(s.hist.cdf 0)) =
   ## Yield `(lo, hi, count)` for each bin covered
   yield (-Inf, -s.b, s.hist.pmf 0)
   yield (-s.b, s.fromIx(1,1.0), s.hist.pmf 1)
   for i in  2   ..<  s.n  :yield (s.fromIx(i,0.0),s.fromIx(i,1.0),s.hist.pmf i)
   yield (-s.a, s.a, s.hist.pmf s.n) # middle bin breaks X⁻¹-mean formula
   for i in s.n+1..<2*s.n-1:yield (s.fromIx(i,0.0),s.fromIx(i,1.0),s.hist.pmf i)
   yield (s.fromIx(2*s.n-1,0.0), +s.b, s.hist.pmf 1)
   yield (+s.b, +Inf, s.hist.pmf 2*s.n)

  proc `$`(s: `T`, minP=2.0*float32.epsilon): string =
    ## Formatting operator; Warning: output can be large, esp. if minP <= 0
    result.add "n: "  & $s.n  & "\ta: " & $s.a & "\tb: "    & $s.b    & "\n"
    result.add "aX: " & $s.aX & "\th: " & $s.h & "\thInv: " & $s.hInv & "\n"
    result.add "totalCount:" & $s.tot & " bins,cnts:\n"
    var n = 0; let t = s.tot.float*minP
    for (a, b, c) in s.bins:
      if c.float >= t:
        result.add "  [ " & $a & " , " & $b & " ): " & $c & "\n"; inc n
    result[^1] = '\n'
    result.add $n & " bins>=" & $t

  func quantile[F](s: `T`, q: F): F =
    ## Basic quantile; XXX More accurate X-spacing-savvy interpolation?
    if q < 0.0 or q > 1.0: return NaN
    var iL, iH: int
    let fL = s.hist.quantile(q, iL, iH)
    fL*s.fromIx(iL) + (1 - fL)*s.fromIx(iH)

  func cdf[F](s: `T`, x: F): type(s.hist.cdf 0) =
    ## Raw count; Leave to caller to multiply by 1/s.hist.count;XXX Interpolate?
    if x.isNaN: NaN else: s.hist.cdf(s.toIx(x))

  func merge(dst: var `T`, src: `T`) =
    ## Merge counts from src into dst.
    if src.n != dst.n or src.a != dst.a or src.b != dst.b:
      Value !! "src-dst histogram parameter mismatch"
    for i in 0..2*src.n: dst.hist.inc i, src.hist.pmf(i) # Flat array prob fastr

when isMainModule:
  {.push warning[UnusedImport]:off.}; {.push hint[DuplicateModuleImport]:off.}
  import adix/[hist, bist,embist,lmbist, lna] # Import everything we *might*..
  from std/math import exp, sqrt              #..need rather than condition.
  template Id(x): untyped  = x              # The identity/linear transform
  template sqr(x: untyped) = x*x            # The sqrt-sqr transform
  const mode {.intdefine.} = 0
  when mode == 0: xhist1.def Histo, Id  , Id , Hist[uint32]
  elif mode == 1: xhist1.def Histo, lna , exp, Bist[uint32]  # Match LgHisto
  elif mode == 2: xhist1.def Histo, Id  , Id , Bist[uint32]
  elif mode == 3: xhist1.def Histo, sqrt, sqr, Bist[uint32]
  elif mode == 4: xhist1.def Histo, lna , exp, EMBist[float32], true, 0.9375
  elif mode == 5: xhist1.def Histo, lna , exp, LMBist[uint32]
  when defined(test): # Helpful to run against: -- -12 -8 -4 -1 0 1 4 8 12
    proc lghist(a=0.125, b=10.0, n=8, qs = @[0.25, 0.5, 0.75], xs: seq[float]) =
      var lh = initHisto(a, b, n)
      for x in xs: lh.add x
      echo `$`(lh, minP=0)
      for (a, b, c) in lh.bins:
        if (a,b) != lh.binAB((a+b)/2) or a >= b:
          echo "a: ",a," b: ",b," c: ",c," ab(mid(a,b)): ",lh.binAB((a+b)/2)
      lh.hist.up
      if lh.tot > 0: (for q in qs: echo "q",q,": ",lh.quantile(q))
    import cligen; dispatch lghist
  else:
    import std/[random, times, strformat]; randomize()
    var data: seq[float32]
    const N = 750_000
    var res = newSeqOfCap[float32](N)
    for i in 1 .. N: data.add gauss().float32 # rand(0.0 .. 1.0)
    var s = initHisto(b=10, n=128)
    let t0 = epochTime()
    for x in data: s.add x
    s.hist.up
    let t1 = epochTime()
    for q in [0.001, 0.01, 0.05, 0.25, 0.50, 0.75, 0.95, 0.99, 0.999]:
      res.add s.quantile(q)
    let t2 = epochTime()
    for r in res: echo r  # do not time the formatting/echo part
    echo &"ns/add: {(t1-t0)*1e9/N.float:.1f}  ns/q: {(t2-t1)*1e9/9:.1f}"
    echo "space: ", s.space, " bytes"
