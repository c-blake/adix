##[`xhist1.def` is a template to make a histogram type for univariate/1D data
monotonically transformed over (0, +Inf) for binning against any integer-keyed
backing histogram.  The backing histogram is itself generic over time weighting
kernels (bist, lmbist, embist..) and those over their counter types (exponential
time-decay needs `SomeFloat`).  The example program at the bottom of the module
should mostly show how to use this.  This generalizes `adix/lghisto`.  Quantile
error is bounded by quantization error which is <~1/2 transformed bin width -
eg. with X=log, about 10^(log10(b/a)/n/2).  Space-time trade-offs depend on how
boundable data ranges are, but underflows & overflows are at least counted
(until counters saturate!).  NOTE: Outer code manages running/moving data window
logic with std/deques|whatever - types generated by this only do bin mapping.]##

when not declared addFloat: import std/formatfloat; export formatfloat
from math import isNaN; export isNaN
import cligen/sysUt; export sysUt

template def*(T, X, X⁻¹, H; Hini: typed = 0) =
  ##[ Here `T` is the type that will be defined along with an `init T`, `H` is
  the type of histogram (e.g. bist[uint32]), X is an expression transforming
  monotonically over (0,+Inf) some input `x`, e.g. `ln`, while `X⁻¹` is its
  inverse function expression, e.g. `exp`.  Besides defining the type, this
  also defines a pile of procedures upon it:
    func underflows\*(s: T): type(s.hist.cdf 0)
    func overflows\*(s: T) : type(s.hist.cdf 0)
    func low\*(s: T): float
    func high\*(s: T): float
    func nBin\*(s: T): int
    func hist\*(s: T): H
    func init\*(s: var T, a=1e-16, b=1e20, n=8300)
    func `init T`\*(a=1e-16, b=1e20, n=8300): T
    func space\*(s: T): int
    func tot\*(s: T): auto
    func toIx\*[F](s: T, x: F): int
    func fromIx\*[F](s: T, i: int, offset: F=0.5): F
    func binAB\*[F](s: T, x: F): (float, float)
    func add\*[F](s: var T, x: F, w: type(s.hist.cdf 0) = 1)
    func pop\*[F](s: var T, x: F, w: type(s.hist.cdf 0) = 1)
    iterator bins\*(s: T): (float, float, type(s.hist.cdf 0))
    proc `$`\*(s: T, nonZero=true): string
    func quantile\*[F](s: T, q: F): F
    func cdf\*[F](s: T, x: F): type(s.hist.cdf 0)
    func merge\*(dst: var T, src: T)
  So, e.g.: `def Histo, ln, exp, Bist[uint32]` is one instantiation. ]##

  type `T`* = object      ## histogram(X(x[])) with backing histogram `H`
    n*: int               ## number of bins
    a*, b*: float         ## histogram covers [-b, -a], (-a, a) in zero, [a, b]
    aX*, h*, hInv*: float ## pre-computes for index scale conversion
    hist*: H              ## actual smart array of counters: [0, 2*n] -> PMF/CDF
#2DO^ Faster flat array option w/cumsum for "final" qtls; LowPrec `ln`=>DataDog.
#Could also take option like `noNegative`, but untouched cache matters little.

  func underflows*(s: `T`): type(s.hist.cdf 0) = s.hist.pmf 0
  func overflows*(s: `T`) : type(s.hist.cdf 0) = s.hist.pmf 2*s.n
  func low*(s: `T`): float      = s.a
  func high*(s: `T`): float     = s.b
  func nBin*(s: `T`): int       = s.n
  func hist*(s: `T`): H         = s.hist

  func init*(s: var `T`, a=1e-16, b=1e20, n=8300) =
    ## Init histo w/2n+1 X-spaced bins: `[-∞..-b; -b..-a; 0; a..<b; b..∞]`.
    if b <= a: Value !! "inverted: [" & $a & "," & $b & "]"
    if a <= 0.0 or b <= 0.0: Value !! "a,b must both be >0"
    if n < 2: Value !! "n must >= 2"
    s.n    = n
    s.a    = a
    s.b    = b
    s.aX   = a.X
    s.h    = (b.X - s.aX)/float(n - 1)
    s.hInv = 1.0/s.h
    when Hini == 0: s.hist.init 2*n + 1
    else          : s.hist.init 2*n + 1, Hini

  func `init T`*(a=1e-16, b=1e20, n=8300): `T` = result.init a, b, n
    ## Get Histo w/2n+1 X-spaced bins: `[-inf..<-b; -b..<-a; 0; a..<b; b..inf]`.

  func space*(s: `T`): int = s.sizeof + s.hist.space
    ## Estimate space taken up by data structure in bytes

  func tot*(s: `T`): auto = s.hist.tot ## Give total count weight

  func toIx*[F](s: `T`, x: F): int =
    ##Find bin index for value `x`; Underflows get `[0]`, Overflows get `[2*n]`.
    if   x <= -s.a:
      if x >= -s.b: result = s.n - 1 - int( (X(-x) - s.aX)*s.hInv)
      else        : result = 0
    elif x >= +s.a:
      if x <= +s.b: result = s.n + 1 + int( (X(+x) - s.aX)*s.hInv)
      else        : result = 2*s.n
    else: result = s.n

  func fromIx*[F](s: `T`, i: int, offset: F=0.5): F =
    ## X⁻¹-mean of left&right edge X-shifted `offset` fraction into bin
    if   i < s.n: -X⁻¹(s.aX + s.h*(F(s.n - i - 1) + F(1) - offset))
    elif i > s.n: +X⁻¹(s.aX + s.h*(F(i - s.n - 1) + offset))
    else: 0.0 # Bin containing x=zero cannot really be offset in the same way

  func binAB*[F](s: `T`, x: F): (float, float) =
    ## Range in data space of the bin containing `x`; Costs 2 `fromIx`s.
    let i = s.toIx(x)
    if   i == 0      : result[0] = -Inf           ; result[1] = -s.b
    elif i == 1      : result[0] = -s.b           ; result[1] = s.fromIx(i,1.0)
    elif i == 2*s.n-1: result[0] = s.fromIx(i,0.0); result[1] = +s.b
    elif i == 2*s.n  : result[0] = +s.b           ; result[1] = +Inf
    elif x <  -s.a   : result[0] = s.fromIx(i,0.0); result[1] = s.fromIx(i,1.0)
    elif x >= +s.a   : result[0] = s.fromIx(i,0.0); result[1] = s.fromIx(i,1.0)
    else             : result[0] = -s.a           ; result[1] = +s.a

  func add*[F](s: var `T`, x: F, w: type(s.hist.cdf 0) = 1) =
    ## Increment bin for value `x` by weight `w`
    if not isNaN(x): s.hist.inc s.toIx(x), w

  func pop*[F](s: var `T`, x: F, w: type(s.hist.cdf 0) = 1) =
    ## Alias for `add` with a negative weight argument
    if not isNaN(x): s.hist.dec s.toIx(x), w

  iterator bins*(s: `T`): (float, float, type(s.hist.cdf 0)) =
   ## Yield `(lo, hi, count)` for each bin covered
   yield (-Inf, -s.b, s.hist.pmf 0)
   yield (-s.b, s.fromIx(1,1.0), s.hist.pmf 1)
   for i in  2   ..<  s.n  :yield (s.fromIx(i,0.0),s.fromIx(i,1.0),s.hist.pmf i)
   yield (-s.a, s.a, s.hist.pmf s.n) # middle bin breaks X⁻¹-mean formula
   for i in s.n+1..<2*s.n-1:yield (s.fromIx(i,0.0),s.fromIx(i,1.0),s.hist.pmf i)
   yield (s.fromIx(2*s.n-1,0.0), +s.b, s.hist.pmf 1)
   yield (+s.b, +Inf, s.hist.pmf 2*s.n)

  proc `$`*(s: `T`, nonZero=true): string =
    ## Formatting operator; Warning: output can be large, esp. if nonZero=false
    result.add "n: "  & $s.n  & "\ta: " & $s.a & "\tb: "    & $s.b    & "\n"
    result.add "aX: " & $s.aX & "\th: " & $s.h & "\thInv: " & $s.hInv & "\n"
    result.add "bins,cnts:\n"
    var tot = 0; var n = 0
    for (a, b, c) in s.bins:
      let c = int c; tot += c
      if nonZero:
       if c != 0: result.add "  [ " & $a & " , " & $b & " ): " & $c & "\n";inc n
      else      : result.add "  [ " & $a & " , " & $b & " ): " & $c & "\n"
    result[^1] = '\n'
    result.add "totalCount: " & $tot & (if nonZero: " non0Bins: " & $n else: "")

  func quantile*[F](s: `T`, q: F): F =
    ## Basic quantile; XXX More accurate X-spacing-savvy interpolation?
    if q < 0.0 or q > 1.0: return NaN
    var iL, iH: int
    let fL = s.hist.quantile(q, iL, iH)
    fL*s.fromIx(iL) + (1 - fL)*s.fromIx(iH)

  func cdf*[F](s: `T`, x: F): type(s.hist.cdf 0) =
    ## Raw count; Leave to caller to multiply by 1/s.hist.count;XXX Interpolate?
    if x.isNaN: NaN else: s.hist.cdf(s.toIx(x))

  func merge*(dst: var `T`, src: `T`) =
    ## Merge counts from src into dst.
    if src.n != dst.n or src.a != dst.a or src.b != dst.b:
      Value !! "src-dst histogram parameter mismatch"
    for i in 0..2*src.n: dst.hist.inc i, src.hist.pmf(i) # Flat array prob fastr

when isMainModule:
  import adix/[bist, lna]                   # embist lmbist
  from std/math import exp                  #, sqrt
  xhist1.def Histo, lna, exp, Bist[uint32]  # Matches lghisto exactly
# template sqr(x: untyped) = x*x
# template Id(x): untyped  = x
# xhist1.def Histo, Id   , Id   , Bist[uint32]   
# xhist1.def Histo, sqrt , sqr  , Bist[uint32]   
# xhist1.def Histo, lna  , exp  , EMBist[float32], 0.9375
# xhist1.def Histo, lna  , exp  , LMBist[uint32] 
  when defined(test): # Helpful to run against: -- -12 -8 -4 -1 0 1 4 8 12
    proc lghist(a=0.125, b=10.0, n=8, qs = @[0.25, 0.5, 0.75], xs: seq[float]) =
      var lh = initHisto(a, b, n)
      for x in xs: lh.add x
      echo `$`(lh, nonZero=false)
      for (a, b, c) in lh.bins:
        if (a,b) != lh.binAB((a+b)/2) or a >= b:
          echo "a: ",a," b: ",b," c: ",c," ab(mid(a,b)): ",lh.binAB((a+b)/2)
      if lh.tot > 0: (for q in qs: echo "q",q,": ",lh.quantile(q))
    import cligen; dispatch lghist
  else:
    import std/[random, times, strformat]; randomize()
    var data: seq[float32]
    const N = 750_000
    var res = newSeqOfCap[float32](N)
    for i in 1 .. N: data.add gauss().float32 # rand(0.0 .. 1.0)
    var s = initHisto(b=10, n=128)
    let t0 = epochTime()
    for x in data: s.add x
    let t1 = epochTime()
    for q in [0.001, 0.01, 0.05, 0.25, 0.50, 0.75, 0.95, 0.99, 0.999]:
      res.add s.quantile(q)
    let t2 = epochTime()
    for r in res: echo r  # do not time the formatting/echo part
    echo &"ns/add: {(t1-t0)*1e9/N.float:.1f}  ns/q: {(t2-t1)*1e9/9:.1f}"
    echo "space: ", s.space, " bytes"
